function loadSolr(i) {
    var f = i.clear;
    var d = i.zoomLevel;
    var c = geohashLevel(d, "geohash");
    if (d > 11) {
        loadSmall(1, d);
        return
    }
    var a = map.getBounds();
    var g = "&fq=geo_coords:" + buildBbox(a);
    var e = [];
    var h = function (w) {
        if (w.response.numFound === 0) {
            map.spin(false);
            return
        }
        var s;
        var v;
        var u;
        var j = ["#ff4b00", "#bac900", "#EC1813", "#55BCBE", "#D2204C", "#FF0000", "#ada59a", "#3e647e"];
        switch (d) {
            case 1:
            case 2:
                s = w.stats.stats_fields.geo_coords_ll_0___tdouble.facets.geohash_1;
                v = w.stats.stats_fields.geo_coords_ll_1___tdouble.facets.geohash_1;
                u = w.facet_counts.facet_pivot["geohash_1,species_category"];
                break;
            case 3:
            case 4:
            case 5:
                s = w.stats.stats_fields.geo_coords_ll_0___tdouble.facets.geohash_2;
                v = w.stats.stats_fields.geo_coords_ll_1___tdouble.facets.geohash_2;
                u = w.facet_counts.facet_pivot["geohash_2,species_category"];
                break;
            case 6:
            case 7:
                s = w.stats.stats_fields.geo_coords_ll_0___tdouble.facets.geohash_3;
                v = w.stats.stats_fields.geo_coords_ll_1___tdouble.facets.geohash_3;
                u = w.facet_counts.facet_pivot["geohash_3,species_category"];
                break;
            case 8:
            case 9:
                s = w.stats.stats_fields.geo_coords_ll_0___tdouble.facets.geohash_4;
                v = w.stats.stats_fields.geo_coords_ll_1___tdouble.facets.geohash_4;
                u = w.facet_counts.facet_pivot["geohash_4,species_category"];
                break;
            case 10:
            case 11:
                s = w.stats.stats_fields.geo_coords_ll_0___tdouble.facets.geohash_5;
                v = w.stats.stats_fields.geo_coords_ll_1___tdouble.facets.geohash_5;
                u = w.facet_counts.facet_pivot["geohash_5,species_category"];
                break;
            default:
                s = w.stats.stats_fields.geo_coords_ll_0___tdouble.facets.geohash_6;
                v = w.stats.stats_fields.geo_coords_ll_1___tdouble.facets.geohash_6;
                u = w.facet_counts.facet_pivot["geohash_6,species_category"];
                break
        }
        smallClusters = [];
        var l = [];
        var k = [];
        var r = [];
        u.forEach(function (B, z, C) {
            l[B.value] = B.count;
            var y = [];
            var x = [];
            var A = 1;
            B.pivot.forEach(function (E) {
                var D = E.value, F = E.count;
                if (A < 8) {
                    y[D] = F
                } else {
                    y.others += F
                }
                x.push({
                    label: D.replace(/sensu lato/, "sl").replace(/chromosomal form/, "cf"),
                    value: F,
                    color: (palette[D] ? palette[D] : "#000000")
                });
                ++A
            });
            k[B.value] = y;
            r[B.value] = x
        });
        for (var q in s) {
            if (s.hasOwnProperty(q)) {
                var o = s[q].count;
                if (o < 2) {
                    smallClusters.push(q);
                    continue
                }
                if (d === 5 && o < 11) {
                    smallClusters.push(q);
                    continue
                }
                if (d === 6 && o < 26) {
                    smallClusters.push(q);
                    continue
                }
                if (d === 7 && o < 41) {
                    smallClusters.push(q);
                    continue
                }
                if (d === 8 && o < 61) {
                    smallClusters.push(q);
                    continue
                }
                if (d === 9 && o < 81) {
                    smallClusters.push(q);
                    continue
                }
                if (d > 9 && o < 101) {
                    smallClusters.push(q);
                    continue
                }
                if (s[q].min === s[q].max && v[q].min === v[q].max) {
                    smallClusters.push(q);
                    continue
                }
                var m = {};
                m.term = q;
                m.count = s[q].count;
                m.latLng = [s[q].mean, v[q].mean];
                m.bounds = [[s[q].min, v[q].min], [s[q].max, v[q].max]];
                m.population = l[q];
                m.stats = k[q];
                m.fullstats = r[q];
                m.colors = j;
                e.push(m)
            }
        }
        var p = {};
        p.terms = e;
        var t = {
            recordsField: "terms",
            latitudeField: "latLng.0",
            longitudeField: "latLng.1",
            displayOptions: {
                count: {
                    title: function (x) {
                        return x
                    }
                }
            },
            layerOptions: {fill: false, stroke: false, weight: 0, color: "#80FF00", dropShadow: false},
            setIcon: function (x) {
                var y = 40;
                return new L.Icon.Canvas({
                    iconSize: new L.Point(y, y),
                    className: "prunecluster leaflet-markercluster-icon lamogio",
                    population: x.population,
                    stats: x.stats
                })
            },
            onEachRecord: function (y, x) {
                y.on("dblclick", function () {
                    map.fitBounds(x.bounds)
                });
                y.on("click", function () {
                    updatePieChart(x.population, x.fullstats)
                });
                y.on("mouseout", function () {
                })
            }
        };
        var n = new L.MarkerDataLayer(p, t);
        if (f) {
            assetLayerGroup.clearLayers();
            assetLayerGroup.addLayer(n)
        } else {
            assetLayerGroup.addLayer(n)
        }
        if (smallClusters.length > 0) {
            loadSmall(0, d)
        }
        map.spin(false)
    };
    var b = "http://funcgen.vectorbase.org/popbio-map-preview/asolr/solr/vb_popbio/select?q=bundle_name:Sample AND has_geodata%3Atrue&rows=0" + g + "&fl=geo_coords&stats=true&stats.field=geo_coords_ll_0___tdouble&stats.field=geo_coords_ll_1___tdouble&stats.facet=" + c + "&facet=true&facet.limit=-1&facet.sort=count&facet.pivot.mincount=1&facet.pivot=" + c + ",species_category&wt=json&indent=true&json.nl=map&json.wrf=?&callback=?";
    map.spin(true);
    $.getJSON(b, h).fail(function () {
        console.log("Ahhh");
        return
    })
}
function loadSmall(h, e, l) {
    var f = new PruneClusterForLeaflet(40);
    f.BuildLeafletClusterIcon = function (i) {
        var m = new L.Icon.MarkerCluster();
        m.stats = i.stats;
        m.population = i.population;
        return m
    };
    var b = ["#ff4b00", "#bac900", "#EC1813", "#55BCBE", "#D2204C", "#FF0000", "#ada59a", "#3e647e"];
    L.Icon.MarkerCluster = L.Icon.extend({
        options: {
            iconSize: new L.Point(40, 40),
            className: "prunecluster leaflet-markercluster-icon"
        }, createIcon: function () {
            var m = document.createElement("canvas");
            this._setIconStyles(m, "icon");
            var i = this.options.iconSize;
            m.width = i.x;
            m.height = i.y;
            this.draw(m.getContext("2d"), i.x, i.y);
            return m
        }, createShadow: function () {
            return null
        }, draw: function (p, n, z) {
            var u = Math.PI * 2, s = Math.PI * 1.5;
            var m = s;
            var v = this.options.iconSize.x, r = v / 2, q = v / 2.5;
            var o = 0;
            var t = 8;
            for (var y in this.stats) {
                if (this.stats.hasOwnProperty(y)) {
                    var A = this.stats[y] / this.population;
                    if (A > 0) {
                        p.beginPath();
                        p.moveTo(r, r);
                        if (palette.hasOwnProperty(y)) {
                            p.fillStyle = palette[y]
                        } else {
                            p.fillStyle = palette.others
                        }
                        var x = m + 0.14, w = m + A * u;
                        if (w < x) {
                            x = m
                        }
                        p.arc(r, r, r, x, w);
                        m = m + A * u;
                        p.lineTo(r, r);
                        p.fill();
                        p.closePath()
                    }
                    --t
                }
            }
            p.beginPath();
            p.fillStyle = "white";
            p.arc(r, r, q, 0, Math.PI * 2);
            p.fill();
            p.closePath();
            p.fillStyle = "#555";
            p.textAlign = "center";
            p.textBaseline = "middle";
            p.font = "bold 12px sans-serif";
            p.fillText(this.population, r, r, v)
        }
    });
    f.BuildLeafletCluster = function (o, n) {
        var i = new L.Marker(n, {icon: f.BuildLeafletClusterIcon(o)});
        i.on("dblclick", function () {
            var r = f.Cluster.FindMarkersInArea(o.bounds);
            var p = f.Cluster.ComputeBounds(r);
            if (p) {
                var s = new L.LatLngBounds(new L.LatLng(p.minLat, p.maxLng), new L.LatLng(p.maxLat, p.minLng));
                var m = f._map.getZoom();
                var q = f._map.getBoundsZoom(s, false, new L.Point(20, 20, null));
                if (q === m) {
                    f._map.fire("overlappingmarkers", {cluster: f, markers: r, center: i.getLatLng(), marker: i})
                } else {
                    f._map.fitBounds(s)
                }
            }
        });
        i.on("click", function () {
            var m = new Array;
            var q = o.stats;
            for (var p in q) {
                m.push({
                    label: p.replace(/sensu lato/, "sl").replace(/chromosomal form/, "cf"),
                    value: q[p],
                    color: (palette[p] ? palette[p] : "#000000")
                })
            }
            updatePieChart(o.population, m)
        });
        i.on("mouseover", function (m) {
        });
        return i
    };
    var d = geohashLevel(e, "geohash");
    var a = map.getBounds();
    var l = "&fq=geo_coords:" + buildBbox(a);
    var j;
    if (h === 0) {
        j = "(";
        for (var g = 0; g < smallClusters.length; g++) {
            if (g === smallClusters.length - 1) {
                j += smallClusters[g];
                break
            }
            j += smallClusters[g] + " OR "
        }
        j += ")"
    } else {
        j = "*"
    }
    var k = function (i) {
        var p = i.response.docs;
        for (var n in p) {
            if (p.hasOwnProperty(n)) {
                var o = p[n].geo_coords.split(",");
                var m = new PruneCluster.Marker(o[0], o[1]);
                if (p[n].hasOwnProperty("species_category")) {
                    m.category = p[n].species_category[0]
                }
                f.RegisterMarker(m)
            }
        }
        if (h) {
            assetLayerGroup.clearLayers()
        }
        assetLayerGroup.addLayer(f);
        map.spin(false)
    };
    var c = "http://funcgen.vectorbase.org/popbio-map-preview/asolr/solr/vb_popbio/select?q=bundle_name:Sample AND has_geodata:true&fq=" + d + ":" + j + "&rows=10000000" + l + "&fl=geo_coords,species_category&wt=json&indent=false&json.nl=map&json.wrf=?&callback=?";
    map.spin(true);
    $.getJSON(c, k)
}
function buildBbox(d) {
    var e;
    if (d.getEast()) {
        var c = d.getSouth();
        if (c < -90) {
            c = -90
        }
        var f = d.getNorth();
        if (f > 90) {
            f = 90
        }
        var a = d.getWest();
        if (a < -180) {
            a = -180
        }
        if (a > 180) {
            a = 180
        }
        var b = d.getEast();
        if (b > 180) {
            b = 180
        }
        if (b < -180) {
            b = -180
        }
        e = "[" + c + "," + a + " TO " + f + "," + b + "]"
    } else {
        e = "[-90,-180 TO 90, 180]"
    }
    return (e)
}
function geohashLevel(b, a) {
    var c;
    if (a === "geohash") {
        switch (b) {
            case 1:
            case 2:
                c = "geohash_1";
                break;
            case 3:
            case 4:
            case 5:
                c = "geohash_2";
                break;
            case 6:
            case 7:
                c = "geohash_3";
                break;
            case 8:
            case 9:
                c = "geohash_4";
                break;
            case 10:
            case 11:
                c = "geohash_5";
                break;
            default:
                c = "geohash_6";
                break
        }
    } else {
    }
    return (c)
}
function buildPalette(b, a, h) {
    var g = [];
    var f = ["#FFB300", "#803E75", "#FF6800", "#A6BDD7", "#C10020", "#CEA262", "#817066", "#007D34", "#F6768E", "#00538A", "#FF7A5C", "#53377A", "#FF8E00", "#B32851", "#F4C800", "#7F180D", "#93AA00", "#593315", "#F13A13", "#232C16"];
    var e = ["#575757", "#A0A0A0", "#FFFFFF", "#2A4BD7", "#1D6914", "#814A19", "#8126C0", "#9DAFFF", "#81C57A", "#E9DEBB", "#AD2323", "#29D0D0", "#FFEE33", "#FF9233", "#FFCDF3"];
    for (var c = 0; c < a; c++) {
        var d = b[c][0];
        g[d] = f[c]
    }
    g.others = "#000000";
    return g
}
function sortHashByValue(c) {
    var b = [];
    for (var a in c) {
        b.push([a, c[a]])
    }
    b.sort(function (e, d) {
        return d[1] - e[1]
    });
    return b
}
function updatePieChart(b, c) {
    if (c) {
        var a = 500;
        var d = $("#graphs").width();
        nv.addGraph(function () {
            var e = nv.models.pieChart().x(function (f) {
                return f.label
            }).y(function (f) {
                return f.value
            }).color(function (f) {
                return f.data.color
            }).showLabels(true).labelThreshold(0.05).labelType("percent").donut(true).donutRatio(0.5).growOnHover(false);
            d3.select("#piechart").datum(c).transition().duration(800).attr("width", d).attr("height", a).call(e);
            nv.utils.windowResize(function () {
                e.update()
            });
            return e
        })
    } else {
    }
};